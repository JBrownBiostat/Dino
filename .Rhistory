method = "L-BFGS-B",
lower = 1e-4, upper = 1e4,
control = list(factr = 1e12))
temp
fitZeros.func <- function(LS, fitOut) {
pZeroMat <- fitOut$pMat
for(i in 1:nrow(pZeroMat)) {
scaleVec <- fitOut$phiVec[i] / exp(LS)
pZeroMat[i, ] <- fitOut$lamPar[i] * exp(LS)
pZeroMat[i, ] <- (scaleVec ^ -1 / (pZeroMat[i, ] + scaleVec ^ (-1))) ^
(scaleVec ^ -1)
}
eZeroVec <- c(colSums(pZeroMat * fitOut$pMat))[order(LS)]
return(eZeroVec)
}
plotGeneQuants.func <- function(y, LS) {
fitOut <- dinoFit.func(y, LS)
zeroVec <- fitZeros.func(LS, fitOut)
nbFit <- MASS::glm.nb(y ~ LS)
nbZero <- (nbFit$theta / (nbFit$fitted.values + nbFit$theta)) ^ nbFit$theta
obsDens <- density(LS[y == 0], from = min(LS), to = max(LS), bw = "SJ")
obsDens$y <- obsDens$y * sum(y == 0) / length(y)
dinoDens <- density(sample(sort(LS), size = max(sum(zeroVec), 20), replace = T, prob = zeroVec),
from = min(LS), to = max(LS), bw = "SJ")
dinoDens$y <- dinoDens$y * max(sum(zeroVec), 20) / length(y)
nbDens <- density(sample(LS, size = max(sum(nbZero), 20), replace = T, prob = nbZero),
from = min(LS), to = max(LS), bw = "SJ")
nbDens$y <- nbDens$y * max(sum(nbZero), 20) / length(y)
plotDat <- data.frame(
y = c(obsDens$y,
dinoDens$y,
nbDens$y),
LS = c(obsDens$x,
dinoDens$x,
nbDens$x),
zClass = rep(c("Obs.", "Dino", "NB"),
c(length(obsDens$y), length(dinoDens$y), length(nbDens$y)))
)
p2 <- ggplot(plotDat, aes(x = LS, y = y, col = zClass)) +
theme_classic() +
geom_line() +
labs(x = "log-LS", y = "Density", color = "Model", title = "Zero probabilities")
plotDat <- data.frame(
y = log1p(y),
LS = LS
)
p1 <- ggplot(plotDat, aes(x = LS, y = y)) +
theme_classic() +
geom_point(size = 0.25) +
labs(x = "log-LS", y = "Expression (log)", title = "Fitted means")
for(i in 1:length(fitOut$lamPar)) {
p1 <- p1 +
geom_abline(slope = 1, intercept = log(fitOut$lamPar[i]), col = 2, alpha = 0.5, lwd = 0.5)
}
p1 <- p1 +
geom_abline(slope = 1, intercept = nbFit$coefficients[1], col = 3, lwd = 0.5)
p <- grid.arrange(p1, p2, nrow = 1)
return(p)
}
###############
## Fit genes ##
###############
rawMeans <- order(rowMeans(rawDat), decreasing = T)
p1 <- plotGeneQuants.func(rawDat[rawMeans[1], ], LS)
dinoFit.func <- function(y, LS) {
if(length(y) > 1e4) {
subInd <- sample.int(length(y), 1e4)
} else {
subInd <- 1:length(y)
}
depth <- LS
slope <- 1
depthRep <- Dino::calcDepthRep(depth[subInd])
prec <- 3
emPar <- list(maxIter = 100, tol = 1, conPar = 25)
outDev <- Dino::calcDev(y[subInd], depth[subInd], depthRep, slope)
cdfList <- list(
eCDF_fun = approxfun(
x = outDev$quant,
y = outDev$pct,
yleft = 0, yright = 1
),
eQuant_fun = approxfun(
x = outDev$pct,
y = outDev$quant,
yleft = -Inf, yright = max(outDev$quant)
)
)
# Run EM
minD <- min(depth)
if(minD < 0) {
fitSlope <- min(slope, (exp(minD - 3) - 1) / (exp(minD) - 1))
} else {
fitSlope <- max(slope, (exp(minD - 3) - 1) / (exp(minD) - 1))
}
parList <- Dino::initEM.func(
y = y[subInd],
slope = fitSlope,
subCDF = cdfList,
depth = depth[subInd],
stepInit = 5
)
nUpdate <- emPar$maxIter
deltaStop <- emPar$tol
iter <- 0
while(iter < nUpdate) {
iter <- iter + 1
parList$d <- -parList$gTilde$gTilde +
parList$S %*% parList$g$g
parList$alpha <- -1
gamInd <- parList$gamList$gamVec + parList$alpha * parList$d[1:parList$J]
if(!all(gamInd >= -75)) {
if(parList$J > 2) {
parList <- Dino::parListUpdate.func(parList)
parList$lLik <- Dino::lLik.func(parList)
parList$S <- parList$S * 0
} else {break}
}
betaInd <- parList$betaVec +
parList$alpha * parList$d[(parList$J + 1):(2 * parList$J)]
if(!all(betaInd > -75)) {
if(parList$J > 2) {
parList <- Dino::parListUpdate.func(parList, doBeta = T)
parList$lLik <- Dino::lLik.func(parList)
parList$S <- parList$S * 0
} else {break}
}
if(any(gamInd > 75) | any(betaInd > 75) | max(gamInd) - min(gamInd) > log(2 * length(subInd))) {
parList$S <- parList$S * 0
}
parList <- Dino::calcStep.func(parList)
dTheta <- parList$parUpdate$parVec -
c(parList$gamList$gamVec, parList$betaVec)
dg <- parList$gUpdate$g - parList$g$g
parList$dgTilde <- Dino::gTildeUpdate.func(parList)
dgTilde <- parList$dgTilde$gTilde - parList$gTilde$gTilde
dThetaStar <- -dgTilde + parList$S %*% dg
parList$S <- parList$S +
c(1 + (t(dg) %*% dThetaStar) / (t(dg) %*% dTheta)) *
(dTheta %*% t(dTheta)) / c(t(dg) %*% dTheta) -
(dThetaStar %*% t(dTheta) + t(dThetaStar %*% t(dTheta))) /
c(t(dg) %*% dTheta)
parList$pList <- parList$pListUpdate
parList$gamList <- parList$parUpdate$gamList
parList$betaVec <- parList$parUpdate$betaVec
parList$g <- parList$gUpdate
parList$gTilde <- parList$dgTilde
if(parList$lLikUpdate - parList$lLik <= deltaStop) {
break
}
parList$lLik <- parList$lLikUpdate
}
parList$pList$spMat <- parList$pList$spMat * exp(parList$pList$lpMax)
lamPar <- pmax(exp(parList$betaVec), .Machine$double.xmin * 1e1)
bw <- tryCatch({
suppressWarnings(bw.ucv(lamPar))
}, error = function(e) {
tryCatch({
bw.nrd(lamPar)
}, error = function(e) {
1 / sqrt(parList$J)
})
})
# phiVec <- rep(bw, parList$J)
muMat <- matrix(lamPar * rep(parList$depth, rep(length(lamPar),
length(parList$depth))),
nrow = length(lamPar))
# for(i in 1:parList$J) {
#   muVec <- lamPar[i] * parList$depth
#   phiVec[i] <- solvePhi.func(parList$y, muVec,
#                              ifelse(i > 1, (phiVec[i - 1] + bw) / 2, bw),
#                              parList$pList$spMat[i, ], parList$depth)
# }
phi <- solvePhi.func(parList$y, muMat, bw, parList$pList$spMat, parList$depth)
# Update model for all points
parList$y <- y
parList$depth <- exp(depth) * fitSlope - fitSlope + 1
parList$pList <- Dino::lpMat.func(parList)
tauPar <- parList$gamList$gamVec - max(parList$gamList$gamVec)
tauPar <- exp(tauPar)
tauPar <- tauPar / sum(tauPar)
tauPar <- pmax(tauPar, .Machine$double.xmin * 1e1)
tauPar <- tauPar / sum(tauPar)
lamPar <- pmax(exp(parList$betaVec), .Machine$double.xmin * 1e1)
parList$pList$spMat <- parList$pList$spMat * exp(parList$pList$lpMax)
# Resample counts
# bw <- tryCatch({
#   suppressWarnings(bw.ucv(lamPar))
# }, error = function(e) {
#   tryCatch({
#     bw.nrd(lamPar)
#   }, error = function(e) {
#     1 / sqrt(parList$J)
#   })
# })
shapeVec <- lamPar / bw
concVec <- emPar$conPar
# fitZero <- countZeros.func(LS[subInd], shapeVec, bw, parList$pList$spMat[, subInd])
# obsZero <- sum(y[subInd] == 0)
# bwDat <- data.frame(
#   bw = rep(bw, 3),
#   zeroDiff = rep((fitZero - obsZero) ^ 2, 3)
# )
# bwDat$bw[1] <- bwDat$bw[1] / 4
# fitZero <- countZeros.func(LS[subInd], lamPar / bwDat$bw[1],
#                            bwDat$bw[1],
#                            parList$pList$spMat[, subInd])
# bwDat$zeroDiff[1] <- (fitZero - obsZero) ^ 2
# bwDat$bw[3] <- bwDat$bw[3] * 4
# fitZero <- countZeros.func(LS[subInd], lamPar / bwDat$bw[3], bwDat$bw[3],
#                            parList$pList$spMat[, subInd])
# bwDat$zeroDiff[3] <- (fitZero - obsZero) ^ 2
# while(bwDat$zeroDiff[1] <= bwDat$zeroDiff[2]) {
#   bwDat[2:3, ] <- bwDat[1:2, ]
#   bwDat$bw[1] <- bwDat$bw[1] / 2
#   fitZero <- countZeros.func(LS[subInd], lamPar / bwDat$bw[1],
#                              bwDat$bw[1],
#                              parList$pList$spMat[, subInd])
#   bwDat$zeroDiff[1] <- (fitZero - obsZero) ^ 2
# }
# while(bwDat$zeroDiff[3] <= bwDat$zeroDiff[2]) {
#   bwDat[1:2, ] <- bwDat[2:3, ]
#   bwDat$bw[3] <- bwDat$bw[3] * 2
#   fitZero <- countZeros.func(LS[subInd], shapeVec, bwDat$bw[3],
#                              parList$pList$spMat[, subInd])
#   bwDat$zeroDiff[3] <- (fitZero - obsZero) ^ 2
# }
# for(i in 1:3) {
#   bwDat <- rbind(
#     bwDat,
#     data.frame(
#       bw = bwDat$bw[1:2] + diff(bwDat$bw) / 2,
#       zeroDiff = 0
#     )
#   )
#   fitZero <- countZeros.func(LS[subInd], lamPar / bwDat$bw[4],
#                              bwDat$bw[4],
#                              parList$pList$spMat[, subInd])
#   bwDat$zeroDiff[4] <- (fitZero - obsZero) ^ 2
#   fitZero <- countZeros.func(LS[subInd], lamPar / bwDat$bw[5],
#                              bwDat$bw[5],
#                              parList$pList$spMat[, subInd])
#   bwDat$zeroDiff[5] <- (fitZero - obsZero) ^ 2
#   bwDat <- bwDat[order(bwDat$bw), ]
#   minInd <- which.min(bwDat$zeroDiff)
#   bwDat <- bwDat[(minInd - 1):(minInd + 1), ]
# }
return(list(
pMat = parList$pList$spMat,
lamPar = lamPar,
phiVec = phiVec,
concVec = concVec
))
}
p1 <- plotGeneQuants.func(rawDat[rawMeans[1], ], LS)
dinoFit.func <- function(y, LS) {
if(length(y) > 1e4) {
subInd <- sample.int(length(y), 1e4)
} else {
subInd <- 1:length(y)
}
depth <- LS
slope <- 1
depthRep <- Dino::calcDepthRep(depth[subInd])
prec <- 3
emPar <- list(maxIter = 100, tol = 1, conPar = 25)
outDev <- Dino::calcDev(y[subInd], depth[subInd], depthRep, slope)
cdfList <- list(
eCDF_fun = approxfun(
x = outDev$quant,
y = outDev$pct,
yleft = 0, yright = 1
),
eQuant_fun = approxfun(
x = outDev$pct,
y = outDev$quant,
yleft = -Inf, yright = max(outDev$quant)
)
)
# Run EM
minD <- min(depth)
if(minD < 0) {
fitSlope <- min(slope, (exp(minD - 3) - 1) / (exp(minD) - 1))
} else {
fitSlope <- max(slope, (exp(minD - 3) - 1) / (exp(minD) - 1))
}
parList <- Dino::initEM.func(
y = y[subInd],
slope = fitSlope,
subCDF = cdfList,
depth = depth[subInd],
stepInit = 5
)
nUpdate <- emPar$maxIter
deltaStop <- emPar$tol
iter <- 0
while(iter < nUpdate) {
iter <- iter + 1
parList$d <- -parList$gTilde$gTilde +
parList$S %*% parList$g$g
parList$alpha <- -1
gamInd <- parList$gamList$gamVec + parList$alpha * parList$d[1:parList$J]
if(!all(gamInd >= -75)) {
if(parList$J > 2) {
parList <- Dino::parListUpdate.func(parList)
parList$lLik <- Dino::lLik.func(parList)
parList$S <- parList$S * 0
} else {break}
}
betaInd <- parList$betaVec +
parList$alpha * parList$d[(parList$J + 1):(2 * parList$J)]
if(!all(betaInd > -75)) {
if(parList$J > 2) {
parList <- Dino::parListUpdate.func(parList, doBeta = T)
parList$lLik <- Dino::lLik.func(parList)
parList$S <- parList$S * 0
} else {break}
}
if(any(gamInd > 75) | any(betaInd > 75) | max(gamInd) - min(gamInd) > log(2 * length(subInd))) {
parList$S <- parList$S * 0
}
parList <- Dino::calcStep.func(parList)
dTheta <- parList$parUpdate$parVec -
c(parList$gamList$gamVec, parList$betaVec)
dg <- parList$gUpdate$g - parList$g$g
parList$dgTilde <- Dino::gTildeUpdate.func(parList)
dgTilde <- parList$dgTilde$gTilde - parList$gTilde$gTilde
dThetaStar <- -dgTilde + parList$S %*% dg
parList$S <- parList$S +
c(1 + (t(dg) %*% dThetaStar) / (t(dg) %*% dTheta)) *
(dTheta %*% t(dTheta)) / c(t(dg) %*% dTheta) -
(dThetaStar %*% t(dTheta) + t(dThetaStar %*% t(dTheta))) /
c(t(dg) %*% dTheta)
parList$pList <- parList$pListUpdate
parList$gamList <- parList$parUpdate$gamList
parList$betaVec <- parList$parUpdate$betaVec
parList$g <- parList$gUpdate
parList$gTilde <- parList$dgTilde
if(parList$lLikUpdate - parList$lLik <= deltaStop) {
break
}
parList$lLik <- parList$lLikUpdate
}
parList$pList$spMat <- parList$pList$spMat * exp(parList$pList$lpMax)
lamPar <- pmax(exp(parList$betaVec), .Machine$double.xmin * 1e1)
bw <- tryCatch({
suppressWarnings(bw.ucv(lamPar))
}, error = function(e) {
tryCatch({
bw.nrd(lamPar)
}, error = function(e) {
1 / sqrt(parList$J)
})
})
# phiVec <- rep(bw, parList$J)
muMat <- matrix(lamPar * rep(parList$depth, rep(length(lamPar),
length(parList$depth))),
nrow = length(lamPar))
# for(i in 1:parList$J) {
#   muVec <- lamPar[i] * parList$depth
#   phiVec[i] <- solvePhi.func(parList$y, muVec,
#                              ifelse(i > 1, (phiVec[i - 1] + bw) / 2, bw),
#                              parList$pList$spMat[i, ], parList$depth)
# }
phi <- solvePhi.func(parList$y, muMat, bw, parList$pList$spMat, parList$depth)
# Update model for all points
parList$y <- y
parList$depth <- exp(depth) * fitSlope - fitSlope + 1
parList$pList <- Dino::lpMat.func(parList)
tauPar <- parList$gamList$gamVec - max(parList$gamList$gamVec)
tauPar <- exp(tauPar)
tauPar <- tauPar / sum(tauPar)
tauPar <- pmax(tauPar, .Machine$double.xmin * 1e1)
tauPar <- tauPar / sum(tauPar)
lamPar <- pmax(exp(parList$betaVec), .Machine$double.xmin * 1e1)
parList$pList$spMat <- parList$pList$spMat * exp(parList$pList$lpMax)
# Resample counts
# bw <- tryCatch({
#   suppressWarnings(bw.ucv(lamPar))
# }, error = function(e) {
#   tryCatch({
#     bw.nrd(lamPar)
#   }, error = function(e) {
#     1 / sqrt(parList$J)
#   })
# })
shapeVec <- lamPar / bw
concVec <- emPar$conPar
# fitZero <- countZeros.func(LS[subInd], shapeVec, bw, parList$pList$spMat[, subInd])
# obsZero <- sum(y[subInd] == 0)
# bwDat <- data.frame(
#   bw = rep(bw, 3),
#   zeroDiff = rep((fitZero - obsZero) ^ 2, 3)
# )
# bwDat$bw[1] <- bwDat$bw[1] / 4
# fitZero <- countZeros.func(LS[subInd], lamPar / bwDat$bw[1],
#                            bwDat$bw[1],
#                            parList$pList$spMat[, subInd])
# bwDat$zeroDiff[1] <- (fitZero - obsZero) ^ 2
# bwDat$bw[3] <- bwDat$bw[3] * 4
# fitZero <- countZeros.func(LS[subInd], lamPar / bwDat$bw[3], bwDat$bw[3],
#                            parList$pList$spMat[, subInd])
# bwDat$zeroDiff[3] <- (fitZero - obsZero) ^ 2
# while(bwDat$zeroDiff[1] <= bwDat$zeroDiff[2]) {
#   bwDat[2:3, ] <- bwDat[1:2, ]
#   bwDat$bw[1] <- bwDat$bw[1] / 2
#   fitZero <- countZeros.func(LS[subInd], lamPar / bwDat$bw[1],
#                              bwDat$bw[1],
#                              parList$pList$spMat[, subInd])
#   bwDat$zeroDiff[1] <- (fitZero - obsZero) ^ 2
# }
# while(bwDat$zeroDiff[3] <= bwDat$zeroDiff[2]) {
#   bwDat[1:2, ] <- bwDat[2:3, ]
#   bwDat$bw[3] <- bwDat$bw[3] * 2
#   fitZero <- countZeros.func(LS[subInd], shapeVec, bwDat$bw[3],
#                              parList$pList$spMat[, subInd])
#   bwDat$zeroDiff[3] <- (fitZero - obsZero) ^ 2
# }
# for(i in 1:3) {
#   bwDat <- rbind(
#     bwDat,
#     data.frame(
#       bw = bwDat$bw[1:2] + diff(bwDat$bw) / 2,
#       zeroDiff = 0
#     )
#   )
#   fitZero <- countZeros.func(LS[subInd], lamPar / bwDat$bw[4],
#                              bwDat$bw[4],
#                              parList$pList$spMat[, subInd])
#   bwDat$zeroDiff[4] <- (fitZero - obsZero) ^ 2
#   fitZero <- countZeros.func(LS[subInd], lamPar / bwDat$bw[5],
#                              bwDat$bw[5],
#                              parList$pList$spMat[, subInd])
#   bwDat$zeroDiff[5] <- (fitZero - obsZero) ^ 2
#   bwDat <- bwDat[order(bwDat$bw), ]
#   minInd <- which.min(bwDat$zeroDiff)
#   bwDat <- bwDat[(minInd - 1):(minInd + 1), ]
# }
return(list(
pMat = parList$pList$spMat,
lamPar = lamPar,
phi = phi,
concVec = concVec
))
}
fitZeros.func <- function(LS, fitOut) {
pZeroMat <- fitOut$pMat
for(i in 1:nrow(pZeroMat)) {
scaleVec <- fitOut$phi / exp(LS)
pZeroMat[i, ] <- fitOut$lamPar[i] * exp(LS)
pZeroMat[i, ] <- (scaleVec ^ -1 / (pZeroMat[i, ] + scaleVec ^ (-1))) ^
(scaleVec ^ -1)
}
eZeroVec <- c(colSums(pZeroMat * fitOut$pMat))[order(LS)]
return(eZeroVec)
}
plotGeneQuants.func <- function(y, LS) {
fitOut <- dinoFit.func(y, LS)
zeroVec <- fitZeros.func(LS, fitOut)
nbFit <- MASS::glm.nb(y ~ LS)
nbZero <- (nbFit$theta / (nbFit$fitted.values + nbFit$theta)) ^ nbFit$theta
obsDens <- density(LS[y == 0], from = min(LS), to = max(LS), bw = "SJ")
obsDens$y <- obsDens$y * sum(y == 0) / length(y)
dinoDens <- density(sample(sort(LS), size = max(sum(zeroVec), 20), replace = T, prob = zeroVec),
from = min(LS), to = max(LS), bw = "SJ")
dinoDens$y <- dinoDens$y * max(sum(zeroVec), 20) / length(y)
nbDens <- density(sample(LS, size = max(sum(nbZero), 20), replace = T, prob = nbZero),
from = min(LS), to = max(LS), bw = "SJ")
nbDens$y <- nbDens$y * max(sum(nbZero), 20) / length(y)
plotDat <- data.frame(
y = c(obsDens$y,
dinoDens$y,
nbDens$y),
LS = c(obsDens$x,
dinoDens$x,
nbDens$x),
zClass = rep(c("Obs.", "Dino", "NB"),
c(length(obsDens$y), length(dinoDens$y), length(nbDens$y)))
)
p2 <- ggplot(plotDat, aes(x = LS, y = y, col = zClass)) +
theme_classic() +
geom_line() +
labs(x = "log-LS", y = "Density", color = "Model", title = "Zero probabilities")
plotDat <- data.frame(
y = log1p(y),
LS = LS
)
p1 <- ggplot(plotDat, aes(x = LS, y = y)) +
theme_classic() +
geom_point(size = 0.25) +
labs(x = "log-LS", y = "Expression (log)", title = "Fitted means")
for(i in 1:length(fitOut$lamPar)) {
p1 <- p1 +
geom_abline(slope = 1, intercept = log(fitOut$lamPar[i]), col = 2, alpha = 0.5, lwd = 0.5)
}
p1 <- p1 +
geom_abline(slope = 1, intercept = nbFit$coefficients[1], col = 3, lwd = 0.5)
p <- grid.arrange(p1, p2, nrow = 1)
return(p)
}
p1 <- plotGeneQuants.func(rawDat[rawMeans[1], ], LS)
p2 <- plotGeneQuants.func(rawDat[rawMeans[2], ], LS)
p3 <- plotGeneQuants.func(rawDat[rawMeans[18], ], LS)
jpeg(paste0(Project_Dir, "ModelFit/ZeroDistributions.jpeg"), height = 8, width = 6,
units = "in", res = 350, quality = 0.99)
grid.arrange(p1, p2, p3, ncol = 1)
dev.off()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
sqrt(25000)
